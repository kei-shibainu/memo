# 01_DB設計メモ
## 論理設計と正規化
+ テーブル名は全て複数形または集合名詞で書ける。
+ 外部キーの参照先の行が存在してリレーションシップが成立していることを参照整合性制約と呼ぶ。
+ 外部キーが設定されている場合参照元が削除されていると整合性が失われるため、参照先から削除することが鉄則。
+ 主キーの選定は可変長文字列ではなく、固定長文字列を採用すること。
+ 制約には参照整合性制約の他に以下の3つの制約がある。
    + NOT NULL制約
    + 一意制約
    + CHECK制約(閾値を定義)
+ テーブル定義においてNULLは様々な誤動作を引き起こすため可能な限りNOT  NULL制約をつける。

### 第一正規形
+ 列Aの値が決まれば自ずと列Bの値も決まる。この状態を関数従属と呼ぶ。
+ 主キー以外の列は主キーに関数従属しているべきである。これを排除することが正規化の手順の目的
+ 第一正規形は'一つのセルの中には一つの値しか含まない'。複数ある場合はこれを分割する。
    + 繰り返しの列の部分を別の表に切り出す
    + 切り出したテーブルの仮の主キーを決める
    + 主キー列をコピーして複合主キーを構成する

### 第二正規形
+ 複合主キーの一部の列に対して従属する列がある場合、部分関数従属と呼ぶ。
+ 対して複合主キー全ての列に従属性がある場合は完全関数従属と呼ぶ。
+ 第二正規形は'部分関数従属を廃し、完全関数従属のみのテーブルを作成する'
   + 複合主キーの一部に関数従属する列を別のテーブルに切り出す
   + 部分関数従属している列をコピーして主キーとする
+ 正規化する前の状態に戻せることを可逆的と呼び、情報を完全に保存したまま分割する操作を無損失分解と呼ぶ。
+ 可逆的操作はSQLの結合構文で結合する。つまり正規化の逆操作は結合である。

### 第三正規形
+ {会社コード, 社員ID} → {部署コード} → {部署名}のように段階的な従属関係のことを推移的関数従属と呼ぶ。
+ この推移的関数従属を解消する作業を第三正規化と呼ぶ。
    + 間接的に主キーに関数従属する列を切り出す。上記の例で言えば{部署名}
    + 直接的に関数従属していた列をコピーし主キーとする。

### まとめ
+ 整理すると正規化とは以下のような汚いテーブルを解消する手法である。
    + 第一正規形は繰り返し列
    + 第二正規形は部分関数従属
    + 第三正規系は推移的関数従属

## ER図
+ テーブル同士の関連性を示した図をER図と呼ぶ
+ 以下のような関連性のパターンがある。この内1対1、多対多は基本的には存在してはいけない。
    + 1対1
    + 1対多
    + 多対多
+ 要件定義から概念設計を実施すると学生と講義のエンティティのように多対多のエンティティが作成されることがあり、  
この場合中間となる連関(関連実体)エンティティを作成し、各の主キーを定義して関連づける。

### IDEF1X
+ 角の四角いエンティティは独立エンティティと呼び他のテーブルに依存することなくデータを保持することのできるエンティティを指す。
+ 角の丸いエンティティは従属エンティティと呼び他のテーブルにデータが存在しなければデータを保持することができないエンティティを指す。
+ ●は0以上、●Pは1以上、●Zは0または1、●nは特定の数を指す
+ 1対多のうち1のほうは●を使用しない。
+ 1の方がnull許容の場合(0または1の場合)は◇を指定する。
+ 1対多の内、多が1に必ず属する場合(NULLでは無い場合)は実線を使用し、依存リレーションシップと呼ぶ
+ 1対多の内、多が1に必ず属さない場合(NULLを許容する場合)は点線を使用し、非依存リレーションシップと呼ぶ

## 論理設計とパフォーマンス
### 正規化の功罪
+ 正規化をすることによってパフォーマンスが劣化する事が多々ある
+ サマリデータや選択条件を冗長に保持すると正規形に違反するが、検索を高速化できる。
+ 原則は高次に正規化を行う。パフォーマンスチューニングやトレードオフの検討が必要な場合に非正規化を行う。
+ 非正規化は更新のパフォーマンスは低下する。また設計変更が発生する。

## データベースとパフォーマンス
### インデックス
+ インデックスとは索引情報を指し、キーとページ番号(ポインタ)の配列を保持する。
+ インデックスの特徴は以下になる。
    + 既存のSQL文に影響を与えない(アプリケーション透過的)
    + テーブルデータに影響を与えない(データ透過的)
+ インデックスは無闇に造るものではない。インデックスは更新性能を劣化させるからである。
+ インデックスはまずはB-tree(平衡木)インデックスを検討する。
+ インデックスは以下の列に作成する。
    + 大規模なテーブル
    + カーディナリティ(多重度)の高い列に作成する
    + 検索条件(Where)、結合条件(Join)、ソート条件(Order By)
+ B-treeインデックスはデータ量が多いほど効果的である。データ量の目安は10万行程度
+ 検索条件のうち以下の場合はインデックスの恩恵を受けられない。「裸」で用いるのが鉄則
    + インデックス列に演算を行っている
    + インデックス列に対してSQL関数を使用している
    + IS NULL演算子を使っている
    + 否定系を用いている
    + 後方一致、中間一致のLIKE構文を使用している
    + 暗黙の型変換を使用している
+ 主キー及び一意制約の列はインデックス作成不要。内部的にはB-treeインデックスを作成している。

### 統計情報
+ 統計情報はテーブルやインデックスなどデータについてのメタデータである。アクセスパスを確認するには統計情報を使用する。
+ SQLはユーザ→パーサ(SQLの解析)→オプティマイザ(最適化)→カタログマネージャ(統計情報の照会)→オプティマイザ→テーブルの順でアクセスする。
+ 統計情報の収集タイミングはデータが大きく更新されたあとなるべく早く取得するのが肝要。
+ 統計情報取得は コストがかかるので夜間帯に実施する(バッチ処理)。
+ インデックス以外にも以下のようなチューニング方法がある。
    + パーティション(仕切り)：特定のキーで物理配置をキーごとにまとめる。
    + パラレルクエリ：通常SQLはシングルタスクで実行されるが、並列実行するようにできる。
    + オンメモリ：基本的なボトルネックはストレージI/Oのため、メモリ上にデータを保持する手法。
    + ヒント句：通常はDBMSが実行計画を立てるが、明らかに性能が良いアクセスパスがある場合は人為的に指定できる。
+ ヒント句は扱いが難しいためパフォーマンスチューニングの最終手段
+ パラレルクエリ、オンメモリはリソースの枯渇が懸念されるためみだりには使用しないこと
+ 都道府県や年度のように多重度が小さい場合はパーティションを用いる。

## 参考
[達人に学ぶDB設計徹底指南書 第2版](https://www.amazon.co.jp/dp/B0D8N5G9GT)